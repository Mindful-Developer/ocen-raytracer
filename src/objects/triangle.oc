import std::vec::{ Vec3f, Vec2f }
import std::value::Value
import @utils::{ vec_from_json }
import @core::ray::Ray
import @core::hitrec::HitRec
import @core::object::Object
import @core::bounds::Bounds


struct Triangle {
    p0: Vec3f
    p1: Vec3f
    p2: Vec3f
    n0: Vec3f
    n1: Vec3f
    n2: Vec3f
    t0: Vec2f
    t1: Vec2f
    t2: Vec2f
}


def Triangle::hit(&this, ray: &Ray, rec: &HitRec, parent: &Object): bool {
    let e0 = .p1 - .p0
    let e1 = .p2 - .p0

    let h = ray.dir.cross(e1)
    let a1 = e0.dot(h)
    if a1 == 0.0 return false

    let f = 1.0 / a1

    let s = ray.pos - .p0
    let v = f * s.dot(h)
    if v < 0.0 or v > 1.0 return false;

    let q = s.cross(e0)
    let w = f * ray.dir.dot(q)
    if w < 0.0 or v + w > 1.0 return false;

    let t = f * e1.dot(q)
    if t < 0.0001 or t > rec.t return false;

    let u = 1.0 - v - w;

    rec.t = t
    rec.norm = u * .n0 + v * .n1 + w * .n2
    rec.pos = ray.at(t)
    rec.uv = .t0 * u + .t1 * v + .t2 * w
    rec.obj = parent

    return true
}

def Triangle::bounds(this): Bounds {
    let bounds = Bounds::empty()
    bounds = bounds.add_point(.p0)
    bounds = bounds.add_point(.p1)
    return bounds.add_point(.p2)
}

def Triangle::from_json(json: &Value): Triangle {
    let p0 = Vec3f(0.0, 0.0, 0.0)
    let p1 = Vec3f(1.0, 0.0, 0.0)
    let p2 = Vec3f(0.0, 1.0, 0.0)

    let n0 = Vec3f(0.0, 0.0, 1.0)
    let n1 = Vec3f(0.0, 0.0, 1.0)
    let n2 = Vec3f(0.0, 0.0, 1.0)

    let t0 = Vec2f(0.0, 0.0)
    let t1 = Vec2f(1.0, 0.0)
    let t2 = Vec2f(0.0, 1.0)

    p0 = vec_from_json(json["p0"])
    p1 = vec_from_json(json["p1"])
    p2 = vec_from_json(json["p2"])

    let default_norm = (p1 - p0).cross(p2 - p0).normalized()

    if "n0" in json {
        n0 = vec_from_json(json["n0"])
    }
    if "n1" in json {
        n1 = vec_from_json(json["n1"])
    }
    if "n2" in json {
        n2 = vec_from_json(json["n2"])
    }

    return Triangle(p0, p1, p2, n0, n1, n2, t0, t1, t2)
}