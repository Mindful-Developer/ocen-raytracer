import std::vec::Vec3f
import std::random::{ RandomState, randf32 }
import std::value::Value
import @utils::{ vec_from_json, float_from_json, int_from_json }
import @core::ray::Ray


struct Camera {
    width: u32
    height: u32
    pos: Vec3f
    top_left: Vec3f
    du: Vec3f
    dv: Vec3f
    num_samples: u32
}

def Camera::make(width: u32, height: u32, focal_length: f32, pos: Vec3f, num_samples: u32): Camera {
    let aspect_ratio = width as f32 / height as f32
    let viewport_height = 2.0
    let viewport_width = viewport_height * aspect_ratio

    let viewport_u = Vec3f(viewport_width, 0.0, 0.0)
    let viewport_v = Vec3f(0.0, -viewport_height, 0.0)

    let du = viewport_u / width as f32
    let dv = viewport_v / height as f32

    let camera_center = pos

    let upper_left = (camera_center 
                      - Vec3f(0.0, 0.0, focal_length) 
                      - viewport_u / 2.0 
                      - viewport_v / 2.0)
    let pixel00_pos = upper_left + 0.5 * (du + dv)

    return Camera(width, height, camera_center, pixel00_pos, du, dv, num_samples)
}

def Camera::create_ray(&this, i: u32, j: u32, rng: &RandomState): Ray {
    let pixel = .top_left + (i as f32 + randf32(rng)) * .du + (j as f32 + randf32(rng)) * .dv
    return Ray(
        .pos,
        (pixel - .pos).normalized()
    )
}

def Camera::from_json(json: &Value): Camera {
    let pos = vec_from_json(json["pos"])

    let samples = if json.contains("samples") {
        yield int_from_json(json["samples"]) as u32
    } else {
        yield 1
    }

    let focal_len = float_from_json(json["focal_len"])
    let width = int_from_json(json["w"]) as u32
    let height = int_from_json(json["h"]) as u32
    return Camera::make(width, height, focal_len, pos, samples)
}
