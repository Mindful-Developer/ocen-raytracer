import std::vec::{ Vec3f, Vec2f}
import std::image::Image
import std::math::PI
import std::random::{ RandomState, randf32 }
import std::value::Value
import std::option::Option
import @core::texture::Texture
import @utils::get_interpolated
import @core::ray::Ray
import @core::matrix::Matrix
import @core::hitrec::HitRec
import @core::object::Object
import @core::camera::Camera


struct Scene {
    camera: Camera
    objects: $[&Object]
    img: Option<Texture>
    img_transform: Matrix
}

def Scene::sky_color(&this, ray: &Ray): Vec3f {
    if .img.is_none() {
        let a = 0.5 * (ray.dir.y + 1.0)
        //return (1.0 - a) * Vec3f(1.0, 1.0, 1.0) + a * Vec3f(0.5, 0.7, 1.0)
        return Vec3f(0.05, 0.05, 0.05)
    } else {
        let d = (.img_transform % ray.dir).normalized()
        let u = d.z.atan2(d.x) / (2.0 * PI) + 0.5
        let v = 0.5 + d.y.asin() / PI
        return .img!!.get(Vec2f(u, v))
    }
}

const num_bounces: u32 = 40

def random_point_on_sphere(rng: &RandomState): Vec3f {
    while true {
        let p = Vec3f(
            randf32(rng),
            randf32(rng),
            randf32(rng),
        ) * 2.0 - 1.0
        let lensq = p.length_sq()
        if (10.0 as f64).pow(-160.0 as f64) as f32 < lensq <= 1.0 then return p / lensq.sqrt()
    }
    assert false
}

def Scene::hit(&this, ray: &Ray, rng: &RandomState): Vec3f {
    let accum = Vec3f(1.0, 1.0, 1.0)
    let current_ray = *ray
    for let i = 0; i < num_bounces; i += 1 {
        let hit = false
        let hit_rec: HitRec
        hit_rec.t = f32::inf()
        for obj in .objects.iter() {
            hit = obj.hit(&current_ray, &hit_rec) or hit
        }
        // if hit return hit_rec.norm * 0.5 + 0.5
        // if hit return hit_rec.obj.texture.get(hit_rec.uv)

        if not hit return .sky_color(&current_ray) * accum
        let obj_color = hit_rec.obj.texture.get(hit_rec.uv)
        if hit_rec.obj.mat is Light then return obj_color * accum
        accum = accum * obj_color
        current_ray.dir = match hit_rec.obj.mat {
            Light => std::panic()
            Diffused => {
                let s = hit_rec.pos + hit_rec.norm + random_point_on_sphere(rng)
                yield (s - hit_rec.pos).normalized()
            }
            Reflective => current_ray.dir.reflect(hit_rec.norm)
            Refractive(idx) => {
                let ri = 0.0
                if current_ray.dir.dot(hit_rec.norm) < 0.0 {
                    ri = 1.0 / idx
                } else {
                    ri = idx
                    hit_rec.norm = -1.0 * hit_rec.norm
                }
                let unit_direction = current_ray.dir.normalized()
                let cos_theta = unit_direction.dot(-1.0 * hit_rec.norm).min(1.0)
                let sin_theta = f32::sqrt(1.0 - cos_theta * cos_theta)

                let cannot_refract = ri * sin_theta > 1.0

                let r0 = (1.0 - ri) / (1.0 + ri)
                r0 = r0 * r0
                let reflectance = r0 + (1.0 - r0) * f32::pow(1.0 - cos_theta, 5.0)

                yield if cannot_refract or reflectance > randf32(rng) {
                    yield unit_direction.reflect(hit_rec.norm)
                } else {
                    let r_out_perp = ri * (unit_direction + cos_theta * hit_rec.norm)
                    let r_out_parallel = -f32::sqrt(f32::abs(1.0 - r_out_perp.length_sq())) * hit_rec.norm
                    yield r_out_perp + r_out_parallel
                }
            }
        }
        current_ray.pos = hit_rec.pos + current_ray.dir * 0.001
    }
    return Vec3f(0.0, 0.0, 0.0)
}

def Scene::from_json(json: &Value): Scene {
    let camera = Camera::from_json(json["camera"])
    let objects: $[&Object] = $[]
    for val in json["objects"].as_list().iter() {
        objects.push(Object::from_json(val))
    }
    let tex = Option<Texture>::None
    let transform = Matrix::identity()

    if json.contains("skybox") {
        let skybox = json["skybox"]
        tex = Some(Texture::from_json(json["skybox"]))

        if skybox.contains("transforms") {
            transform = Matrix::from_json(skybox["transforms"])
        }
    }

    return Scene(camera, objects, tex, transform)
}