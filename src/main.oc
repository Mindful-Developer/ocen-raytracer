import std::image::{ Image, Color, bilinear_interp }
import std::vec::{ Vec3f, Vec2f }
import std::math::PI
import std::math
import std::fs
import std::random::{ RandomState, randf32 }
import std::video_renderer::VideoRenderer
import std::gc
import std::json::parse_from_file
import std::argparse::Parser
import @core::camera::Camera
import @core::matrix::Matrix
import @core::scene::Scene
import @core::ray::Ray
import @core::object::Object
import @objects::sphere::Sphere
import @objects::triangle::Triangle
import @objects::mesh::Mesh
import @objects::transformed::Transformed
import @core::bvh::BVH


def main(argc: i32, argv: &str) {
    let parser = Parser::make("ocen-raytracer")
    let scene_path = parser.add_str("scene", help:"Path to the scene JSON file")
    let out_file = parser.add_str("-o", help:"Path to the output image file", defolt:"./build/out.png")
    parser.parse(argc, argv)
    let scene = Scene::from_json(parse_from_file(*scene_path))
    let image = Image::new(scene.camera.width, scene.camera.height)
    render(image, &scene)
    image.save(*out_file)
}

def render(img: &Image, scene: &Scene) {
    let completed = 0

    OMP_PARALLEL_FOR
    for let j = 0; j < img.height; j += 1 {
        let rng = RandomState::make(j)
        for let i = 0; i < img.width; i += 1 {
            let color = Vec3f(0.0, 0.0, 0.0)
            for let s = 0; s < scene.camera.num_samples ; s += 1 {
                let ray = scene.camera.create_ray(i, j, &rng)
                color = color + scene.hit(&ray, &rng)
            }
            img.set(i, j, Color::from_vec(color / scene.camera.num_samples as f32))
        }
        completed += 1
        print(f"\r  {completed}/{img.height}")
    }
}

def std::image::Color::from_vec(vec: Vec3f): Color {
    let ir = (vec.x.clamp01() * 255.999) as u8
    let ig = (vec.y.clamp01() * 255.999) as u8
    let ib = (vec.z.clamp01() * 255.999) as u8

    return Color(ir, ig, ib)
}


/// internal

@compiler c_flag "-O3 -Xpreprocessor -fopenmp -lomp"

// This is a super-ugly hack to allow us to use C-preprocessor macros
[extern "#pragma omp parallel for schedule(dynamic, 32)"]
let OMP_PARALLEL_FOR: i32
